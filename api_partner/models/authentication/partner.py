import logging

from api_admin.helpers import DB_ADMIN
from api_partner.helpers import DB_USER_PARTNER
from api_partner.helpers.choices.partner_status import PartnerStatusCHO
from django.contrib.auth import get_user_model
from django.db import models
from django.db.models import Q
from django.utils import timezone
from django.utils.translation import gettext as _

logger = logging.getLogger(__name__)
User = get_user_model()


class Partner(models.Model):
    """
    """

    user = models.OneToOneField(User, on_delete=models.DO_NOTHING, primary_key=True)

    @property
    def _user(self):
        """
        Get user core model on User DB
        """
        filters = [Q(id=self.user_id)]
        return User.objects.using(DB_USER_PARTNER).filter(*filters).first()

    adviser_id = models.BigIntegerField(default=None, null=True)

    # Payment to Adviser, null value indicates no payment from partner
    fixed_income_adviser_percentage = models.FloatField(null=True, default=None)
    """
    Percentage to pay to adviser for each fixed_income generated by partner
    """
    net_revenue_adviser_percentage = models.FloatField(null=True, default=None)

    # referred status and payment information.
    referred_by = models.ForeignKey("self", null=True, default=None, on_delete=models.SET_NULL)
    """
    self reference to be a referred
    """
    fixed_income_referred_percentage = models.FloatField(null=True, default=None)
    """
    Percentage to pay to referred/sub-partner fixed income generated by other partner
    """
    net_revenue_referred_percentage = models.FloatField(null=True, default=None)
    """
    Percentage to pay to referred/sub-partner net_revenue generated by other partner
    """

    @property
    def adviser(self):
        """
        Get user core model on Admin DB, this is a nullable field
        """
        from api_admin.models import Admin

        # Only if adviser_id is not null get instance
        if self.adviser_id:
            filters = [Q(id=self.adviser_id)]
            return Admin.objects.using(DB_ADMIN).filter(*filters).first()

    is_enterprise = models.BooleanField(default=False)
    was_linked = models.BooleanField(default=False)
    agreement = models.BooleanField(default=True)

    class Status(models.IntegerChoices):
        """
        Defines status for partner account according to document status or
        external cases such as ban or active
        """
        # ambos sin subir (sin información)
        REGISTERED = 0

        # base info subida (por verificar) - sin info financiera (sin información)
        PENDING_BASIC_INFO = 1
        PENDING_BANK_INFO = 2
        # base info (validada) - info financiera(sin información)
        BASIC_INFO_APPROVED = 3

        # información básica rechaza - financiero sin subir
        BASIC_INFO_REJECTED = 4

        # -básica aceptado - financiero rechazado
        BANK_INFO_REJECTED = 5

        BANK_INFO_APPROVED = 6
        # -ambos aceptados
        VALIDATED = 7

        # -undefined condition
        UNDEFINED = 8

    status = models.SmallIntegerField(default=Status.REGISTERED)

    def get_status(self):
        """
        Get Status according to document status combinations, this will
        recalculated only on cases when user send data to_be_verified, upload
        partial of phases data and when admins accepted, Rejected parts of the
        documents procedures and unban the user.
        """
        REQUESTED = PartnerStatusCHO.REQUESTED
        ACCEPTED = PartnerStatusCHO.ACCEPTED
        REJECTED = PartnerStatusCHO.REJECTED

        # user doesn't have information and dont requested anything
        if self.basic_info_status == None:
            return self.Status.REGISTERED
        # user just requested basic info but doesnt send anthing of bankstatus
        elif self.basic_info_status == REQUESTED:
            return self.Status.PENDING_BASIC_INFO
        # basic info rejected and bank status anythin
        elif self.basic_info_status == REJECTED:
            return self.Status.BASIC_INFO_REJECTED
        # basic info approved
        elif self.basic_info_status == ACCEPTED and self.bank_status == None:
            return self.Status.BASIC_INFO_APPROVED
        # basic info accepted and banks status is request
        elif self.basic_info_status == ACCEPTED and self.bank_status == REQUESTED:
            return self.Status.PENDING_BANK_INFO
        # basic info is accepted and bank is rejected
        elif self.basic_info_status == ACCEPTED and self.bank_status == REJECTED:
            return self.Status.BANK_INFO_REJECTED
        # both are accepted
        elif self.basic_info_status == ACCEPTED and self.bank_status == ACCEPTED:
            return self.Status.VALIDATED
        else:
            # undefined case
            logger.error(
                f"Undefined status reached for user pk {self.pk} with email {self.user.email} and status:\n"
                f"basic_info_status {self.basic_info_status}\n"
                f"bank_status {self.bank_status}\n"
                f"level_status {self.level_status}"
            )
            return self.Status.UNDEFINED

    class ValidationStatus(models.IntegerChoices):
        """
        Status for parts of data of partner
        """

        TO_UPLOAD = 0  # POR DEFECTO
        UPLOADED = 1
        TO_BE_VERIFIED = 2
        VALIDATED = 3  # ACEPTADO
        UNDEFINED = 4  # RECHAZA

    basic_info_status = models.SmallIntegerField(null=True, default=None)
    bank_status = models.SmallIntegerField(null=True, default=None)
    secondary_bank_status = models.SmallIntegerField(null=True, default=None)
    documents_status = models.SmallIntegerField(default=ValidationStatus.TO_UPLOAD)
    level_status = models.SmallIntegerField(null=True, default=None)

    def alerts_dict():
        return {
            "basic_info": False,
            "bank": False,
            "secondary_bank": False,
            "level": False,
        }
    alerts = models.JSONField(default=alerts_dict)
    full_registered_at = models.DateTimeField(null=True, default=None)

    class ValidPhoneBy(models.IntegerChoices):
        SMS = 0, "SMS"
        WPP = 1, "WHATSAPP"

    valid_phone_by = models.SmallIntegerField(
        default=None,
        null=True
    )

    level = models.SmallIntegerField(null=True, default=None)
    """
    use integer choices api_partner.helper.choices.level_partner.Level
    """
    is_email_valid = models.BooleanField(default=False)
    is_phone_valid = models.BooleanField(default=False)

    is_notify_campaign = models.BooleanField(default=False)
    notify_campaign_at = models.DateTimeField(default=timezone.now)
    is_notify_notice = models.BooleanField(default=False)
    notify_notice_at = models.DateTimeField(default=timezone.now)
    is_terms = models.BooleanField(default=True)
    terms_at = models.DateTimeField(null=True, default=timezone.now)
    last_rejected_billed_info_at = models.DateTimeField(null=True)
    last_rejected_level_at = models.DateTimeField(null=True)

    class CampaignStatus(models.IntegerChoices):
        VIEW = 0
        NOT_VIEW = 1

    campaign_status = models.SmallIntegerField(default=CampaignStatus.VIEW)

    class RegSource(models.IntegerChoices):
        LANDING = 0
        GO_REDIRECT = 1
        ERROR_REDIRECT = 2
    reg_source = models.SmallIntegerField(default=0)

    class Meta:
        verbose_name = "Partner"
        verbose_name_plural = "Partners"

    def __str__(self):
        return f"{self._user.get_full_name()} - {self._user.email}"
